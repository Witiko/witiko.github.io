---
layout: post
title: "Static analysis of expl3 programs (11Â½): Chunks, edges, flow graphs, confidence, and reaching definitions"
tags:
  - expl3
  - LaTeX
  - programming
  - devlog
date: 2025-11-24
last_modified_at: 2025-11-25
excerpt_separator: <!-- more -->
---

Over the past two months, I released [three][9] [new][10] [updates][2] of
[_expltools_][1], the bundle that provides the _explcheck_ static analyzer for
the expl3 programming language.

These updates include major improvements but did not yet advance the final
stage of the pipeline, **flow analysis**, which I teased in the [previous
post][3]. That's because our work on **flow analysis** so far has been
groundwork: figuring out how to adapt static-analysis techniques to expl3
before moving on to implementation.

In this post, I outline the flow graph structure currently used to represent
expl3 code and describe our adaptation of [the reaching definitions
algorithm][4] for dynamically scoped languages like expl3.

<!-- more -->

# Chunks, edges, and flow graphs
In the [previous post][3], we introduced [segments][5] as the units of
top-level code in expl3 parts and nested code in T- and F-branches of
conditionals, function definitions, and others. Each segment contains zero or
more [statements][6] found during **semantic analysis**.

**Flow analysis** links statements using directed _edges_ to form a _flow
graph_. It also partitions each segment into _chunks_: sequences of recognized
statements separated by `OTHER_TOKENS_COMPLEX` statements, which contain
arbitrary TeX code that may have side effects.

{% include image.html url="er-diagram-2.svg" thumburl="er-diagram-2.png"
   description="Entity relationship diagram of the analysis data model, highlighting our representation of input files." %}

# Static edges and confidence
Some edges arise directly from the static structure of an expl3 program. These
are known without extra analysis and are called _static edges_.

The most common static edge is `AFTER`, which represents moving to the next
statement. We add `AFTER` edges as follows:

1. Connect the last statement of each chunk in an expl3 part to the first
   statement of the first chunk in the next expl3 part.
2. Connect the last statement of each chunk to the first statement of the next
   chunk in the same segment.

Within a chunk, most statements follow each other deterministically. Although
_explcheck_ does not explicitly record these internal edges, they are also
treated as `AFTER` for analysis.

Other common static edges are `TF_BRANCH` and `TF_BRANCH_RETURN`:

3. For each conditional function, add a `TF_BRANCH` edge to the first statements
   of the first chunks in its T- and F-branches.
4. For each T- and F-branch, add a `TF_BRANCH_RETURN` edge from the last
   statement of its last chunk to the statement following its conditional
   function.

All these edges come with varying certainty: TeX code between chunks may change
the execution state in arbitrary ways, and a conditional function only executes
one branch. Edges therefore have a _confidence_ of either `MAYBE` or
`DEFINITELY`.

For `AFTER` edges, the confidence is usually `MAYBE`; it becomes
`DEFINITELY` only between immediately adjacent expl3 parts or between
consecutive statements in the same chunk when the first statement has no
out-edges.

For `TF_BRANCH` edges, the confidence is always `MAYBE`, since we generally do
not know which branch will run. For `TF_BRANCH_RETURN`, the confidence is always
`DEFINITELY`, because once a branch runs, control always returns from it.

# Dynamic edges and reaching definitions
Other edges depend on runtime behavior and dynamic scoping. These require
estimation and are called _dynamic edges_.

A key example is function calls and returns: `FUNCTION_CALL` and
`FUNCTION_CALL_RETURN`. Determining them requires knowing which function
definitions may reach each call.

If a function name has only one definition, we might assume that definition is
used. But that definition may not reach the call. And often, multiple
definitions share the same name, so we must determine which ones can reach the
call.

We start by building only the static edges. Then we run [the reaching
definitions algorithm][8]. Afterwards, we insert dynamic edges:

1. For each function call, add a `FUNCTION_CALL` edge to the first statement of
   the first chunk in every definition that reaches it.
2. For each definition, add a `FUNCTION_CALL_RETURN` edge from the last
   statement of its last chunk to the statement following any call it can reach.

The confidence of each dynamic edge is the minimum confidence along the path
from the definition to the call. <!-- If there are multiple paths, then we use
the maximum confidence from within these paths. -->

However, this first pass does not capture definitions created dynamically
inside function calls. Consider the following example:

    \cs_new:Nn
      \example_bar:
      { bar }
    \cs_new:Nn
      \example_foo:
      {
        \cs_set:Nn
          \example_bar:
          { baz }
      }
    \example_foo:
    \example_bar:

The final call to `\example_bar:` should use the redefinition inside
`\example_foo:` (expands to `baz`), not the original definition on the first
three lines (expands to `bar`). A naive pass would get this wrong.

To handle cases like this, we iterate:

1. Add dynamic edges based on the current reaching definitions.
2. Run reaching definitions again.
3. Replace the old dynamic edges with the new ones.
4. Repeat until nothing changes.

Intuitively, the process converges because each round finishes some calls
(their reaching definitions no longer depend on other unfinished calls),
and the set of unfinished calls strictly decreases. When no edges change, we
have reached a fixed point.

In the example above, both calls are unfinished initially. After the first
iteration, the call to `\example_foo:` becomes finished, but the call to
`\example_bar:` remains unfinished. After the second iteration, the
`\example_bar:` call also becomes finished because its reaching definition
shifts to the redefinition inside `\example_foo:`. No unfinished calls remain,
no edges change, and the algorithm stabilizes.

# Get involved!

Your feedback is invaluable. Feel free to contribute or share your thoughts by
visiting [the project repository][7]. More improvements are on the way as
_explcheck_ continues to grow.

 [1]: https://ctan.org/pkg/expltools
 [2]: https://github.com/Witiko/expltools/releases/tag/2025-11-24
 [3]: /Expl3-Linter-11
 [4]: https://en.wikipedia.org/wiki/Reaching_definition#As_analysis
 [5]: /Expl3-Linter-11#segments
 [6]: /Expl3-Linter-9/#what-is-semantic-analysis
 [7]: https://mirrors.ctan.org/support/expltools/doc/warnings-and-errors.pdf
 [8]: https://en.wikipedia.org/wiki/Reaching_definition#As_analysis
 [9]: https://github.com/Witiko/expltools/releases/tag/2025-10-04
 [10]: https://github.com/Witiko/expltools/releases/tag/2025-10-22
